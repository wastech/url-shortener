package com.wastech.url_shortener.service;

import com.wastech.url_shortener.util.Base62;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.Set;
import java.util.concurrent.TimeUnit;

@Service
@RequiredArgsConstructor
@Slf4j
public class KeyGenerationService {

    private final StringRedisTemplate redisTemplate;
    private final RedissonClient redissonClient; // For distributed locks
    private static final String KEY_POOL_SET = "shortener:key_pool";
    private static final String KEY_COUNTER = "shortener:key_counter";
    private static final String KEY_GEN_LOCK = "shortener:key_gen_lock";
    private static final int MIN_KEY_POOL_SIZE = 10000; // Refill when pool size drops
    private static final int GENERATE_BATCH_SIZE = 50000; // How many keys to generate at once
    private static final int SHORT_CODE_LENGTH = 7; // Fixed length for short codes

    // Scheduled to run periodically to check and replenish the key pool
    @Scheduled(fixedRate = 30000) // Every 30 seconds
    public void replenishKeyPool() {
        RLock lock = redissonClient.getLock(KEY_GEN_LOCK);
        try {
            // Acquire lock with a timeout to prevent deadlocks
            if (lock.tryLock(10, 30, TimeUnit.SECONDS)) {
                Long currentPoolSize = redisTemplate.opsForSet().size(KEY_POOL_SET);
                log.info("Current key pool size: {}", currentPoolSize);

                if (currentPoolSize == null || currentPoolSize < MIN_KEY_POOL_SIZE) {
                    log.info("Replenishing key pool. Generating {} new keys.", GENERATE_BATCH_SIZE);
                    generateAndAddKeys(GENERATE_BATCH_SIZE);
                }
            } else {
                log.warn("Could not acquire key generation lock. Another instance might be generating keys.");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Key generation interrupted: {}", e.getMessage());
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }

    private void generateAndAddKeys(int count) {
        Set<String> newKeys = new java.util.HashSet<>();
        long startId = redisTemplate.opsForValue().increment(KEY_COUNTER, 1) - 1; // Get current counter value
        long nextIdToGenerate = startId;

        for (int i = 0; i < count; i++) {
            // Atomically increment the counter and use its value for base62 encoding
            // The increment is done outside the loop to reduce Redis calls,
            // but the counter itself is incremented by the batch size.
            // A more robust approach might involve incrementing by 1 *inside* a loop for strict single key uniqueness per increment
            // or by batch size if managing IDs carefully across instances.
            // For simplicity here, we're assuming the KGS ensures starting point uniqueness for each batch.
            String newKey = Base62.encodeWithPadding(nextIdToGenerate++, SHORT_CODE_LENGTH);
            newKeys.add(newKey);
        }

        // Add all generated keys to the Redis set
        // SADD command handles duplicates implicitly, though our generation ensures uniqueness
        redisTemplate.opsForSet().add(KEY_POOL_SET, newKeys.toArray(new String[0]));
        log.info("Added {} new keys to the pool.", newKeys.size());
    }

    public String getUniqueKey() {
        String key = redisTemplate.opsForSet().pop(KEY_POOL_SET); // Atomically pop a key
        if (key == null) {
            log.error("Key pool is empty! Attempting to generate on demand (emergency).");
            // FALLBACK: If pool is empty, generate one immediately. This is a bad sign for production scale.
            // In a real system, you'd likely reject the request or trigger an alert.
            // For a demo, let's do an emergency generation.
            long emergencyId = redisTemplate.opsForValue().increment(KEY_COUNTER);
            key = Base62.encodeWithPadding(emergencyId, SHORT_CODE_LENGTH);
            log.warn("Emergency generated key: {}", key);
            // This emergency key might collide if it was already generated by another instance in a batch and is now in use.
            // This is why pre-generation with the Redisson lock is crucial.
            // For absolute safety, if the pool is empty, it's better to tell the user to retry later
            // or block until a key is available (which negates high throughput).
        }
        return key;
    }

    // Optional: Get current pool size
    public Long getKeyPoolSize() {
        return redisTemplate.opsForSet().size(KEY_POOL_SET);
    }
}